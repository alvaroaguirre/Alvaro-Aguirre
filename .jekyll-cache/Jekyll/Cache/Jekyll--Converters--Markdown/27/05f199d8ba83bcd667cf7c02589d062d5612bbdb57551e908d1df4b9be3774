I"Ë'<h2 id="projects">Projects</h2>

<h3 id="benfords-law">Benford‚Äôs Law</h3>

<p>I recently learned about <a href="https://en.wikipedia.org/wiki/Benford%27s_law">Benford‚Äôs Law</a> and could not believe it was real. It basically says that the distribution of the leading digit of real-world data is not uniform, as one would expect, regardless of the unit measured, and it actually always has the same distribution. So obviously I had to test this. I used two datasets. First, I downloaded daily stock prices from CRSP for all US publicly traded stocks during 2019, which is almost 2 million observations. Then, I downloaded a Coronavirus dataset from <a href="https://ourworldindata.org/">Our world in data</a>. I wrote a little Python script using Pandas and Numpy to get the distribution of leading non-zero digits and‚Ä¶ Benford‚Äôs Law holds! Amazing! Below is a one of the distribution plots I generated. I wrote a more detailed blog post <a href="./blog/benford/benfords_law.html">here</a>.</p>

<p><img src="./blog/benford/benford_corona.svg" alt="Benford2" /></p>

<h3 id="numerical-computing-language-speed-r-julia-matlab-and-python">Numerical computing language speed: R, Julia, Matlab and Python</h3>

<p>While doing research at the Systemic Risk Centre, I wrote an article with Jon Danielsson to be published at Vox EU about the speed of numerical computing languages for finance. In particular, we wanted to test R, Julia, Matlab and Python. We performed various benchmark tests. For example, we read a large dataset both compressed (~1GB) and uncompressed (~8GB), which includes all the CRSP database. R‚Äôs data.table package was unparalled for this task. We also performed a GARCH log-likelihood calculations and compared the computing time with a code we wrote in C, which was of course the fastest. Here Julia and Matlab beated base R and base Python, but when decorating R with Rcpp and Python with Numba, these were the fastest. We also included a test on performing group calcuations on the large dataset. You can find all the details in <a href="https://github.com/alvaroaguirre/Projects/tree/master/Speed">this</a> github repository.</p>

<p><img src="https://raw.githubusercontent.com/alvaroaguirre/Projects/f77d54118933e726a2dcce0d862dbd778d5c5ddd/Speed/plots/svg/reading_time.svg" alt="Reading_speed" />
<img src="https://github.com/alvaroaguirre/Projects/blob/master/Speed/plots/png_large/garch.png?raw=true" alt="Computing_speed" /></p>

<h3 id="chaotic-art">Chaotic Art</h3>

<p>I have always been fascinated by the beauty and aesthetics found in mathematics. During my time at the LSE I discovered Chaos Theory, and realized that playing around with different dynamical systems and delay plots could generate beautiful pieces. Here are some examples, you can find more details <a href="https://github.com/alvaroaguirre/NonLinearDynamics/tree/master/ChaoticArt">here</a>.</p>

<p>The pieces shown below are (in order):<br />
<em>Unravelling</em><br />
<em>Lorenz‚Äôs Coccon</em><br />
<em>Ikeda‚Äôs eye</em></p>

<p><img src="https://user-images.githubusercontent.com/29491896/84319417-e9c1e100-ab67-11ea-8e92-8b2d9449e86e.gif" alt="Sloth" /></p>

<p><a href="https://user-images.githubusercontent.com/29491896/84307058-40252480-ab54-11ea-97b8-100acf966755.jpg"><img src="https://user-images.githubusercontent.com/29491896/84307058-40252480-ab54-11ea-97b8-100acf966755.jpg" /></a></p>

<p><a href="https://user-images.githubusercontent.com/29491896/84302654-8fb42200-ab4d-11ea-9464-9dc4f6266028.jpg"><img src="https://user-images.githubusercontent.com/29491896/84302654-8fb42200-ab4d-11ea-9464-9dc4f6266028.jpg" /></a></p>

<h3 id="collatzs-contrapunctus">Collatz‚Äôs Contrapunctus</h3>

<p>Reading ‚ÄúG√∂del, Escher, Bach‚Äù by Douglas Hofstadter was a very enriching experience, and made me think a lot about the intersection of mathematics and music. One of my favorite bands, Vulfpeck, released a music video called <a href="https://www.youtube.com/watch?v=vJfiOuDdetg">‚ÄúBach Vision Test‚Äù</a>, which beautifully shows a visual representation of <em>Die Kunst der Fuge, Contrapunctus IX, a 4 alla Duodecima</em>, which is a four-voiced fugue, where each one is represented by a colored line on a black background that moves up and down depending on the notes. While reading the book, I regained interest in Collatz‚Äôs Conjecture, which I had initially learnt about during a lunch with a mathematician friend a few years ago. I found the plot of stopping times amusing, and for small integers (&lt;300), the plot semeed to have two ‚Äúvoices‚Äù. So I thought it would be nice to follow Vulfpeck‚Äôs idea and animate stopping times with two voices as if it were a counterpoint or fugue. I also wrote some code in R that transform Collatz‚Äôs stopping numbers into musical notes and plays a melody with them. You can find the code <a href="https://github.com/alvaroaguirre/Projects/blob/master/collatz_music.R">here</a>.</p>

<p>I wonder if Lothar Collatz was a fan of Bach:</p>

<p><img src="https://user-images.githubusercontent.com/29491896/84673706-f9ec0e80-af21-11ea-8dc4-59990ec7911b.gif" alt="Collatz" /></p>

<h3 id="outlook-cleaner-for-mac">Outlook cleaner for Mac</h3>

<p>Due to the pandemic I had to work on my personal computer while doing research for the Systemic Risk Center. Since there was a lot of computing involved, it didn‚Äôt take long until my small Macbook Pro‚Äôs disk filled up. This motivated me to dig deep into my files and try to find a way to clean things up. I use the Outlook app for my mac, and realized that it had been written several Gb (I‚Äôve had the same email for around 14 years!). Basically, Outlook downloads messages and attachments in your computer, and there is no option to only keep downloaded emails from the last X days. I have been trying to learn some more python so I wrote a little program that deletes all hidden Outlook files older than a year (you can change this to any number of days). Note that this does not delete any emails, only the downloaded data on your computer, you can still access those messages online and re-download them anytime. You can find the program <a href="https://github.com/alvaroaguirre/Projects/tree/master/Outlook_cleaner">here</a>.</p>

<h3 id="credit-data-from-the-bank-for-international-settlements">Credit data from the Bank for International Settlements</h3>

<p>I had to do some work with data from the Bank for International Settlements. I built an R notebook that automatically downloads data from the BIS using an API and creates functions to easily make plots for credits to the non-financial sector, including: government, households, private non-fin, non-fin corporations, non-fin sector. The plots can be created for a single country or for several countries with the same syntax. You can find the notebook <a href="https://github.com/alvaroaguirre/Projects/tree/master/BIS">here</a>, and a sample plot:</p>

<p><img src="https://raw.githubusercontent.com/alvaroaguirre/Projects/master/BIS/non-financial-2005.png" alt="" /></p>

<h3 id="simple-whatsapp-conversation-analysis-with-python">Simple Whatsapp conversation analysis with Python</h3>

<p>I find natural language data very interesting, especially after reading Ben Blatt‚Äôs <em>Nabokov‚Äôs favorite word is mauve</em>. I mostly do my data work in R, so I decided to try to use basic Python and Pandas to do some simply analysis on Whatsapp conversations. You can easily export chats from the Whatsapp app, so I wrote some code that gets and plots the daily messages sent, groups them by sender, checks the average message length, and finally gives you the most common words used by sender, excluding stopwords. The code has been made general, so you can check out the Jupyter notebook <a href="https://github.com/alvaroaguirre/Projects/blob/master/Whatsapp/whatsapp.ipynb">here</a> and try it with your own chat.</p>

<p><img src="https://raw.githubusercontent.com/alvaroaguirre/Projects/master/Whatsapp/whatsapp.png" alt="Whatsapp" /></p>

<h3 id="building-sierpi≈Ñski-triangles">Building Sierpi≈Ñski triangles</h3>

<p>Fractals are incredibly soothing. After watching <a href="https://www.youtube.com/watch?v=kbKtFN71Lfs">this video</a> from Numberphile, I decided to write a simple code that uses a chaotic game algorithm to draw Sierpi≈Ñski triangles from randomly selected initial points. <a href="https://github.com/alvaroaguirre/NonLinearDynamics/blob/master/sierpinski.R">Here</a> you can find the code and run it. Every time you will get a different fractal.</p>

<p><img src="https://user-images.githubusercontent.com/29491896/84321310-d19f9100-ab6a-11ea-9214-3fc92feb87fa.gif" alt="Sierpinski" /></p>

<h3 id="project-euler">Project Euler</h3>

<p>I enjoy logic puzzles and math challenges, so when I found out about <a href="https://projecteuler.net">Project Euler</a>, I was thrilled.</p>

<p>In <a href="https://github.com/alvaroaguirre/Project_Euler">this</a> github repository you will find my solutions for some problems, written in Python. I plan on keep adding solutions there. If you would like us to work on a problem together, I would love to. Please email me and we can arrange a meeting.</p>

<p><img src="https://projecteuler.net/images/euler_portrait.png" /></p>

<h3 id="contests-with-uncertainty-on-success-functions">Contests with Uncertainty on Success Functions</h3>

<p>Microeconomic models on Contest Theory in recent years have introduced asymmetries in costs, valuations, and information. However, most of them take for granted that the map from the vector of efforts to the probabilities of winning, known as the Contest Success Function, is part of the agents‚Äô common knowledge. For my bachelors‚Äô thesis I built a simple model adding a stochastic component in the CSF, plus information asymmetries between the participating agents, and proposed an application to electoral competitions. The paper was published in the Volume VII of the <a href="https://econreview.berkeley.edu">Berkeley Economic Review</a></p>

<p><a href="https://econreview.berkeley.edu"><img src="https://user-images.githubusercontent.com/29491896/84324905-7755fe80-ab71-11ea-9bc3-cc3b20c55316.png" /></a></p>
:ET